name: CDK Diff

on:
  workflow_call:
    inputs:
      working-directory:
        description: 'Working directory for CDK commands'
        required: false
        type: string
        default: '.'
      python-version:
        description: 'Python version (for Python CDK apps)'
        required: false
        type: string
        default: ''
      node-version:
        description: 'Node.js version'
        required: false
        type: string
        default: '20'
      aws-region:
        description: 'AWS region'
        required: false
        type: string
        default: 'us-east-1'
      aws-role-arn:
        description: 'AWS IAM role ARN to assume'
        required: true
        type: string
      stacks:
        description: 'Space-separated list of stack names to diff'
        required: true
        type: string
      install-command:
        description: 'Command to install dependencies'
        required: false
        type: string
        default: 'npm ci'
      enable-drift-detection:
        description: 'Whether to run drift detection'
        required: false
        type: boolean
        default: true
      account-names:
        description: 'JSON map of account IDs to friendly names (e.g. {"123456789012": "production"})'
        required: false
        type: string
        default: '{}'

jobs:
  diff:
    name: CDK Diff
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        if: inputs.python-version != ''
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}

      - name: Install dependencies
        run: ${{ inputs.install-command }}

      - name: Install AWS CDK CLI
        run: npm install -g aws-cdk

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws-role-arn }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws-region }}

      - name: Synth CDK app
        run: npx cdk synth --quiet --output cdk.out

      - name: Run CDK Diff and Drift Detection
        id: diff
        env:
          STACKS: ${{ inputs.stacks }}
          ENABLE_DRIFT: ${{ inputs.enable-drift-detection }}
          AWS_REGION: ${{ inputs.aws-region }}
          ACCOUNT_NAMES: ${{ inputs.account-names }}
        run: |
          echo "=== Starting CDK Diff ==="
          
          CURRENT_ACCOUNT=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "Current AWS account: $CURRENT_ACCOUNT"
          
          ORIGINAL_ACCESS_KEY="$AWS_ACCESS_KEY_ID"
          ORIGINAL_SECRET_KEY="$AWS_SECRET_ACCESS_KEY"
          ORIGINAL_SESSION_TOKEN="$AWS_SESSION_TOKEN"
          
          RESULTS="[]"
          
          get_stack_account() {
            local stack_name="$1"
            if [ -f "cdk.out/manifest.json" ]; then
              local account=$(jq -r ".artifacts[\"$stack_name\"].environment // \"\"" cdk.out/manifest.json 2>/dev/null | sed -E 's/aws:\/\/([0-9]+)\/.*/\1/')
              if [ -n "$account" ] && [ "$account" != "null" ] && [ "$account" != "" ]; then
                echo "$account"
                return
              fi
            fi
            echo "$CURRENT_ACCOUNT"
          }
          
          get_account_name() {
            local account_id="$1"
            local name=$(echo "$ACCOUNT_NAMES" | jq -r ".[\"$account_id\"] // \"\"" 2>/dev/null)
            if [ -n "$name" ] && [ "$name" != "null" ] && [ "$name" != "" ]; then
              echo "$name"
            else
              echo "$account_id"
            fi
          }
          
          get_cf_stack_name() {
            local cdk_stack="$1"
            if [ -f "cdk.out/manifest.json" ]; then
              local cf_name=$(jq -r ".artifacts[\"$cdk_stack\"].properties.stackName // \"$cdk_stack\"" cdk.out/manifest.json 2>/dev/null)
              if [ -n "$cf_name" ] && [ "$cf_name" != "null" ]; then
                echo "$cf_name"
              else
                echo "$cdk_stack"
              fi
            else
              echo "$cdk_stack"
            fi
          }
          
          restore_credentials() {
            export AWS_ACCESS_KEY_ID="$ORIGINAL_ACCESS_KEY"
            export AWS_SECRET_ACCESS_KEY="$ORIGINAL_SECRET_KEY"
            export AWS_SESSION_TOKEN="$ORIGINAL_SESSION_TOKEN"
          }
          
          assume_target_role() {
            local target_account="$1"
            local region="$AWS_REGION"
            local lookup_role="arn:aws:iam::${target_account}:role/cdk-hnb659fds-lookup-role-${target_account}-${region}"
            
            local creds=$(aws sts assume-role \
              --role-arn "$lookup_role" \
              --role-session-name "cdk-diff-session" \
              --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
              --output text 2>/dev/null) || true
            
            if [ -n "$creds" ]; then
              export AWS_ACCESS_KEY_ID=$(echo "$creds" | cut -f1)
              export AWS_SECRET_ACCESS_KEY=$(echo "$creds" | cut -f2)
              export AWS_SESSION_TOKEN=$(echo "$creds" | cut -f3)
              return 0
            fi
            return 1
          }
          
          for STACK in $STACKS; do
            echo ""
            echo "=== Processing stack: $STACK ==="
            
            TARGET_ACCOUNT=$(get_stack_account "$STACK")
            CF_STACK_NAME=$(get_cf_stack_name "$STACK")
            ACCOUNT_NAME=$(get_account_name "$TARGET_ACCOUNT")
            
            echo "Target account: $TARGET_ACCOUNT ($ACCOUNT_NAME)"
            echo "CloudFormation stack name: $CF_STACK_NAME"
            
            # Assume role if cross-account
            if [ "$TARGET_ACCOUNT" != "$CURRENT_ACCOUNT" ]; then
              assume_target_role "$TARGET_ACCOUNT" || true
            fi
            
            # Initialize variables
            ADDS=0
            UPDATES=0
            DESTROYS=0
            REPLACES=0
            CHANGE_SET_CHANGES="[]"
            STACK_EXISTS="false"
            
            # Check if stack exists
            if aws cloudformation describe-stacks --stack-name "$CF_STACK_NAME" >/dev/null 2>&1; then
              STACK_EXISTS="true"
            fi
            
            # Get the template from cdk.out
            TEMPLATE_FILE="cdk.out/${STACK}.template.json"
            if [ ! -f "$TEMPLATE_FILE" ]; then
              echo "Template file not found: $TEMPLATE_FILE"
              TEMPLATE_FILE="cdk.out/${CF_STACK_NAME}.template.json"
            fi
            
            if [ -f "$TEMPLATE_FILE" ]; then
              echo "Using template: $TEMPLATE_FILE"
              
              # Create a change set to get structured diff
              CHANGE_SET_NAME="cdk-diff-$(date +%s)-$RANDOM"
              
              echo "Creating change set: $CHANGE_SET_NAME"
              
              if [ "$STACK_EXISTS" = "true" ]; then
                CHANGE_SET_TYPE="UPDATE"
              else
                CHANGE_SET_TYPE="CREATE"
              fi
              
              # Create the change set
              CREATE_OUTPUT=$(aws cloudformation create-change-set \
                --stack-name "$CF_STACK_NAME" \
                --change-set-name "$CHANGE_SET_NAME" \
                --template-body "file://$TEMPLATE_FILE" \
                --change-set-type "$CHANGE_SET_TYPE" \
                --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND \
                2>&1) || true
              
              if echo "$CREATE_OUTPUT" | grep -q "ChangeSetId"; then
                echo "Change set created, waiting for it to complete..."
                
                # Wait for change set to be ready
                for i in {1..30}; do
                  sleep 2
                  CS_STATUS=$(aws cloudformation describe-change-set \
                    --stack-name "$CF_STACK_NAME" \
                    --change-set-name "$CHANGE_SET_NAME" \
                    --query 'Status' --output text 2>/dev/null) || echo "FAILED"
                  
                  if [ "$CS_STATUS" = "CREATE_COMPLETE" ] || [ "$CS_STATUS" = "FAILED" ]; then
                    break
                  fi
                done
                
                echo "Change set status: $CS_STATUS"
                
                if [ "$CS_STATUS" = "CREATE_COMPLETE" ]; then
                  # Get the changes from the change set
                  CHANGE_SET_CHANGES=$(aws cloudformation describe-change-set \
                    --stack-name "$CF_STACK_NAME" \
                    --change-set-name "$CHANGE_SET_NAME" \
                    --query 'Changes[].ResourceChange.{Action:Action,LogicalId:LogicalResourceId,Type:ResourceType,Replacement:Replacement,Details:Details}' \
                    --output json 2>/dev/null) || echo "[]"
                  
                  # Count changes by type
                  ADDS=$(echo "$CHANGE_SET_CHANGES" | jq '[.[] | select(.Action == "Add")] | length' 2>/dev/null || echo "0")
                  UPDATES=$(echo "$CHANGE_SET_CHANGES" | jq '[.[] | select(.Action == "Modify")] | length' 2>/dev/null || echo "0")
                  DESTROYS=$(echo "$CHANGE_SET_CHANGES" | jq '[.[] | select(.Action == "Remove")] | length' 2>/dev/null || echo "0")
                  REPLACES=$(echo "$CHANGE_SET_CHANGES" | jq '[.[] | select(.Replacement == true or .Replacement == "True")] | length' 2>/dev/null || echo "0")
                elif [ "$CS_STATUS" = "FAILED" ]; then
                  # Check if failed because no changes
                  CS_REASON=$(aws cloudformation describe-change-set \
                    --stack-name "$CF_STACK_NAME" \
                    --change-set-name "$CHANGE_SET_NAME" \
                    --query 'StatusReason' --output text 2>/dev/null) || echo ""
                  
                  if echo "$CS_REASON" | grep -qi "didn't contain changes\|No updates are to be performed"; then
                    echo "No changes detected"
                  else
                    echo "Change set failed: $CS_REASON"
                  fi
                fi
                
                # Delete the change set
                aws cloudformation delete-change-set \
                  --stack-name "$CF_STACK_NAME" \
                  --change-set-name "$CHANGE_SET_NAME" 2>/dev/null || true
              else
                echo "Failed to create change set: $CREATE_OUTPUT"
                # If stack doesn't exist, this is a new stack
                if [ "$STACK_EXISTS" = "false" ]; then
                  # Count resources in template as adds
                  ADDS=$(jq '.Resources | length' "$TEMPLATE_FILE" 2>/dev/null || echo "0")
                fi
              fi
            fi
            
            # Ensure numbers are valid
            ADDS=${ADDS:-0}
            UPDATES=${UPDATES:-0}
            DESTROYS=${DESTROYS:-0}
            REPLACES=${REPLACES:-0}
            [[ "$ADDS" =~ ^[0-9]+$ ]] || ADDS=0
            [[ "$UPDATES" =~ ^[0-9]+$ ]] || UPDATES=0
            [[ "$DESTROYS" =~ ^[0-9]+$ ]] || DESTROYS=0
            [[ "$REPLACES" =~ ^[0-9]+$ ]] || REPLACES=0
            
            # Drift detection
            DRIFT_STATUS="‚è≠Ô∏è Skipped"
            DRIFT_DETAILS=""
            
            if [ "$ENABLE_DRIFT" = "true" ]; then
              if aws cloudformation describe-stacks --stack-name "$CF_STACK_NAME" >/dev/null 2>&1; then
                DRIFT_ID=$(aws cloudformation detect-stack-drift --stack-name "$CF_STACK_NAME" --query 'StackDriftDetectionId' --output text 2>/dev/null) || true
                
                if [ -n "$DRIFT_ID" ] && [ "$DRIFT_ID" != "None" ]; then
                  for i in {1..12}; do
                    sleep 5
                    DRIFT_CHECK=$(aws cloudformation describe-stack-drift-detection-status \
                      --stack-drift-detection-id "$DRIFT_ID" \
                      --query 'DetectionStatus' --output text 2>/dev/null) || echo "FAILED"
                    
                    if [ "$DRIFT_CHECK" = "DETECTION_COMPLETE" ]; then
                      DRIFT_RESULT=$(aws cloudformation describe-stack-drift-detection-status \
                        --stack-drift-detection-id "$DRIFT_ID" \
                        --query 'StackDriftStatus' --output text 2>/dev/null) || echo "UNKNOWN"
                      
                      if [ "$DRIFT_RESULT" = "IN_SYNC" ]; then
                        DRIFT_STATUS="‚úÖ In Sync"
                      elif [ "$DRIFT_RESULT" = "DRIFTED" ]; then
                        DRIFT_STATUS="üö® Drifted"
                        # Get drifted resources with property differences
                        DRIFT_DETAILS=$(aws cloudformation describe-stack-resource-drifts \
                          --stack-name "$CF_STACK_NAME" \
                          --stack-resource-drift-status-filters MODIFIED DELETED \
                          --query 'StackResourceDrifts[].{Type:ResourceType,Id:LogicalResourceId,Status:StackResourceDriftStatus,Props:PropertyDifferences}' \
                          --output json 2>/dev/null) || echo "[]"
                      else
                        DRIFT_STATUS="‚ö†Ô∏è $DRIFT_RESULT"
                      fi
                      break
                    elif [ "$DRIFT_CHECK" = "DETECTION_FAILED" ]; then
                      DRIFT_STATUS="‚ö†Ô∏è Not Supported"
                      break
                    fi
                  done
                else
                  DRIFT_STATUS="‚ö†Ô∏è Not Supported"
                fi
              else
                DRIFT_STATUS="üÜï Not Deployed"
              fi
            fi
            
            restore_credentials
            
            # Handle change set changes
            if [ -z "$CHANGE_SET_CHANGES" ] || [ "$CHANGE_SET_CHANGES" = "null" ]; then
              CHANGE_SET_CHANGES="[]"
            fi
            CHANGES_ESCAPED=$(echo "$CHANGE_SET_CHANGES" | jq -c '.' 2>/dev/null || echo "[]")
            
            # Handle drift details
            if [ -z "$DRIFT_DETAILS" ]; then
              DRIFT_DETAILS_ESCAPED="[]"
            else
              DRIFT_DETAILS_ESCAPED=$(echo "$DRIFT_DETAILS" | jq -c '.' 2>/dev/null || echo "[]")
            fi
            
            # Build result with structured change set data
            RESULT=$(jq -n \
              --arg stack "$STACK" \
              --argjson adds "$ADDS" \
              --argjson updates "$UPDATES" \
              --argjson destroys "$DESTROYS" \
              --argjson replaces "$REPLACES" \
              --arg drift "$DRIFT_STATUS" \
              --argjson drift_details "$DRIFT_DETAILS_ESCAPED" \
              --argjson changes "$CHANGES_ESCAPED" \
              --arg account_name "$ACCOUNT_NAME" \
              --arg stack_exists "$STACK_EXISTS" \
              '{stack: $stack, adds: $adds, updates: $updates, destroys: $destroys, replaces: $replaces, drift: $drift, drift_details: $drift_details, changes: $changes, account_name: $account_name, stack_exists: $stack_exists}')
            
            RESULTS=$(echo "$RESULTS" | jq --argjson result "$RESULT" '. + [$result]')
          done
          
          echo "results<<EOF" >> $GITHUB_OUTPUT
          echo "$RESULTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post PR Comment
        uses: actions/github-script@v7
        env:
          RESULTS: ${{ steps.diff.outputs.results }}
          ENABLE_DRIFT: ${{ inputs.enable-drift-detection }}
        with:
          script: |
            const results = JSON.parse(process.env.RESULTS || '[]');
            const enableDrift = process.env.ENABLE_DRIFT === 'true';
            
            // Build the comment body
            const stackSections = results.map(r => {
              const hasChanges = r.adds + r.updates + r.destroys + r.replaces > 0;
              const changes = r.changes || [];
              
              // Stack header with summary
              let header = `### üì¶ ${r.stack}`;
              header += ` _(${r.account_name})_`;
              
              let content = '';
              
              // Check if this is a new stack
              if (r.stack_exists === 'false') {
                content = `\n\nüÜï **New Stack** - ${r.adds} resources will be created\n`;
              } else if (!hasChanges || changes.length === 0) {
                content = '\n\n‚úÖ No changes\n';
              } else {
                // Show each resource change from the change set
                for (const change of changes) {
                  const action = change.Action;
                  const logicalId = change.LogicalId;
                  const resourceType = (change.Type || '').replace('AWS::', '');
                  const isReplace = change.Replacement === true || change.Replacement === 'True' || change.Replacement === 'Conditional';
                  const details = change.Details || [];
                  
                  // Determine icon and action text
                  let icon, actionText;
                  if (isReplace) {
                    icon = 'üü†';
                    actionText = 'Replace';
                  } else if (action === 'Add') {
                    icon = 'üü¢';
                    actionText = 'Add';
                  } else if (action === 'Modify') {
                    icon = 'üü°';
                    actionText = 'Update';
                  } else if (action === 'Remove') {
                    icon = 'üî¥';
                    actionText = 'Delete';
                  } else {
                    icon = '‚ùì';
                    actionText = action;
                  }
                  
                  content += `\n\n${icon} **${actionText}** \`${logicalId}\` (\`${resourceType}\`)\n`;
                  
                  // Show property changes if available
                  if (details.length > 0) {
                    const propertyChanges = details
                      .filter(d => d.Target && d.Target.Name)
                      .map(d => ({
                        name: d.Target.Name,
                        requiresRecreation: d.Target.RequiresRecreation,
                        changeSource: d.ChangeSource
                      }));
                    
                    if (propertyChanges.length > 0) {
                      content += '| Property | Recreate? |\n|----------|----------|\n';
                      for (const prop of propertyChanges) {
                        const recreate = prop.requiresRecreation === 'Always' ? '‚ö†Ô∏è Yes' 
                          : prop.requiresRecreation === 'Conditionally' ? '‚ùì Maybe' 
                          : '‚úÖ No';
                        content += `| \`${prop.name}\` | ${recreate} |\n`;
                      }
                    }
                  }
                }
              }
              
              // Drift section
              if (enableDrift) {
                content += `\n**Drift:** ${r.drift}`;
                
                if (r.drift.includes('Drifted') && r.drift_details && r.drift_details.length > 0) {
                  for (const d of r.drift_details.slice(0, 15)) {
                    content += `\n\n**\`${d.Id}\`** (\`${d.Type.replace('AWS::', '')}\`)\n`;
                    if (d.Props && d.Props.length > 0) {
                      content += '| Property | Expected | Actual |\n|----------|----------|--------|\n';
                      for (const p of d.Props) {
                        const path = p.PropertyPath || 'unknown';
                        const expected = p.ExpectedValue != null ? String(p.ExpectedValue) : '_(not set)_';
                        const actual = p.ActualValue != null ? String(p.ActualValue) : '_(not set)_';
                        content += `| \`${path}\` | \`${expected}\` | \`${actual}\` |\n`;
                      }
                    } else {
                      content += '_No property details available_\n';
                    }
                  }
                }
              }
              
              return `<details open>\n<summary>${header}</summary>\n${content}\n</details>`;
            }).join('\n\n');
            
            // Calculate totals
            const totals = results.reduce((acc, r) => ({
              adds: acc.adds + r.adds,
              updates: acc.updates + r.updates,
              destroys: acc.destroys + r.destroys,
              replaces: acc.replaces + r.replaces
            }), { adds: 0, updates: 0, destroys: 0, replaces: 0 });
            
            const totalChanges = totals.adds + totals.updates + totals.destroys + totals.replaces;
            
            let summaryLine = totalChanges === 0 
              ? '‚úÖ **No infrastructure changes**'
              : `**${totalChanges} resource changes:** üü¢ ${totals.adds} add | üü° ${totals.updates} update | üü† ${totals.replaces} replace | üî¥ ${totals.destroys} destroy`;
            
            const hasDrift = results.some(r => r.drift.includes('Drifted'));
            if (enableDrift && hasDrift) {
              summaryLine += ' | üö® **Drift detected**';
            }
            
            const body = [
              '## üèóÔ∏è CDK Diff',
              '',
              summaryLine,
              '',
              stackSections,
              '',
              '---',
              `<sub>Generated at ${new Date().toISOString()} from commit <code>${context.sha.substring(0, 7)}</code></sub>`
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(c => c.body.includes('## üèóÔ∏è CDK Diff'));
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }
