# =============================================================================
# CDK DIFF WORKFLOW (using @aws-cdk/toolkit-lib)
# =============================================================================
# Runs CDK diff in parallel for each account using matrix strategy.
# Each account gets its own OIDC authentication - no cross-account trust needed.
# =============================================================================

name: CDK Diff

on:
  workflow_call:
    inputs:
      working-directory:
        description: 'Working directory for CDK commands'
        required: false
        type: string
        default: '.'
      python-version:
        description: 'Python version (for Python CDK apps)'
        required: false
        type: string
        default: ''
      node-version:
        description: 'Node.js version (18+ required)'
        required: false
        type: string
        default: '20'
      install-command:
        description: 'Command to install dependencies'
        required: false
        type: string
        default: 'npm ci'
      aws-region:
        description: 'AWS region'
        required: false
        type: string
        default: 'us-east-1'
      aws-role-arn:
        description: 'AWS IAM role ARN (single account mode)'
        required: false
        type: string
        default: ''
      aws-role-arns:
        description: 'JSON map of account IDs to role ARNs (multi-account)'
        required: false
        type: string
        default: ''
      stacks:
        description: 'Space-separated stack names (single account)'
        required: false
        type: string
        default: ''
      stacks-per-account:
        description: 'JSON map of account IDs to stack lists (multi-account)'
        required: false
        type: string
        default: ''
      enable-drift-detection:
        description: 'Run drift detection'
        required: false
        type: boolean
        default: true
      account-names:
        description: 'JSON map of account IDs to friendly names'
        required: false
        type: string
        default: '{}'
      pr-number:
        description: 'Pull request number'
        required: false
        type: number
        default: 0
      slack-notify-label:
        description: 'PR label that triggers Slack notification'
        required: false
        type: string
        default: 'slack-notify'
    secrets:
      slack-webhook-url:
        description: 'Slack webhook URL'
        required: false

jobs:
  # ===========================================================================
  # PREPARE: Build matrix of accounts to diff
  # ===========================================================================
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      is-multi-account: ${{ steps.matrix.outputs.is_multi }}
    steps:
      - name: Build matrix
        id: matrix
        run: |
          if [ -n '${{ inputs.aws-role-arns }}' ] && [ -n '${{ inputs.stacks-per-account }}' ]; then
            echo "is_multi=true" >> $GITHUB_OUTPUT
            # Build matrix from role ARNs and stacks
            MATRIX=$(echo '${{ inputs.aws-role-arns }}' | jq -c --argjson stacks '${{ inputs.stacks-per-account }}' '
              to_entries | map({
                account: .key,
                role: .value,
                stacks: ($stacks[.key] // "")
              }) | {include: .}
            ')
            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          else
            echo "is_multi=false" >> $GITHUB_OUTPUT
            echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # SINGLE ACCOUNT MODE
  # ===========================================================================
  diff-single:
    name: CDK Diff
    if: needs.prepare.outputs.is-multi-account == 'false' && inputs.aws-role-arn != ''
    needs: prepare
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    outputs:
      result: ${{ steps.diff.outputs.result }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        if: inputs.python-version != ''
        with:
          python-version: ${{ inputs.python-version }}
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
      - run: ${{ inputs.install-command }}
      - run: npm install -g aws-cdk
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws-role-arn }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws-region }}
      - name: Run diff
        id: diff
        env:
          STACKS: ${{ inputs.stacks }}
          ENABLE_DRIFT: ${{ inputs.enable-drift-detection }}
        run: |
          npx cdk synth --quiet --output cdk.out
          
          mkdir -p /tmp/cdk-runner && cd /tmp/cdk-runner
          echo '{"type":"module","dependencies":{"@aws-cdk/toolkit-lib":"*"}}' > package.json
          npm install --silent
          
          cat > run.js << 'SCRIPT'
          import { Toolkit, StackSelectionStrategy } from '@aws-cdk/toolkit-lib';
          const stacks = (process.env.STACKS || '').split(' ').filter(Boolean);
          const enableDrift = process.env.ENABLE_DRIFT === 'true';
          async function main() {
            const output = { success: false, stacks: [], error: '' };
            try {
              const toolkit = new Toolkit({ ioHost: { notify: async () => {}, requestResponse: async (msg) => msg.defaultResponse } });
              const cx = await toolkit.fromAssemblyDirectory(process.env.CDK_OUT);
              const selector = stacks.length ? { strategy: StackSelectionStrategy.PATTERN_MUST_MATCH, patterns: stacks } : { strategy: StackSelectionStrategy.ALL_STACKS };
              const diffResults = await toolkit.diff(cx, { stacks: selector });
              const fmtVal = (v) => v === undefined || v === null ? null : typeof v === 'object' ? JSON.stringify(v) : String(v);
              for (const [name, diff] of Object.entries(diffResults)) {
                const result = { stackName: name, hasDiff: false, resources: [] };
                for (const [logicalId, resDiff] of Object.entries(diff.resources?.diffs || {})) {
                  const type = resDiff.resourceTypes?.newType || resDiff.resourceTypes?.oldType || 'Unknown';
                  const action = resDiff.isAddition ? 'ADD' : resDiff.isRemoval ? 'REMOVE' : 'UPDATE';
                  const properties = Object.entries(resDiff.propertyDiffs || {}).filter(([_, p]) => p.isDifferent).map(([n, p]) => ({ name: n, impact: p.changeImpact || 'UNKNOWN', oldValue: fmtVal(p.oldValue), newValue: fmtVal(p.newValue) }));
                  result.resources.push({ logicalId, type, action, properties });
                  result.hasDiff = true;
                }
                if (enableDrift) { try { const dr = await toolkit.drift(cx, { stacks: { strategy: StackSelectionStrategy.PATTERN_MUST_MATCH, patterns: [name] } }); result.drift = { status: (dr[name]?.numResourcesWithDrift || 0) > 0 ? 'DRIFTED' : 'IN_SYNC', count: dr[name]?.numResourcesWithDrift || 0 }; } catch {} }
                output.stacks.push(result);
              }
              output.success = true;
            } catch (e) { output.error = e.message || String(e); }
            console.log(JSON.stringify(output));
          }
          main();
          SCRIPT
          
          cd ${{ github.workspace }}/${{ inputs.working-directory }}
          CDK_OUT="$(pwd)/cdk.out" node /tmp/cdk-runner/run.js > /tmp/result.json 2>&1 || true
          RESULT=$(cat /tmp/result.json | tail -1 || echo '{"success":false,"error":"no output","stacks":[]}')
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$RESULT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # ===========================================================================
  # MULTI-ACCOUNT: Parallel matrix jobs
  # ===========================================================================
  diff-multi:
    name: Diff (${{ matrix.account }})
    if: needs.prepare.outputs.is-multi-account == 'true'
    needs: prepare
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    outputs:
      # Matrix outputs - collected by aggregate job
      result: ${{ steps.diff.outputs.result }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        if: inputs.python-version != ''
        with:
          python-version: ${{ inputs.python-version }}
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
      - run: ${{ inputs.install-command }}
      - run: npm install -g aws-cdk

      - name: Configure AWS (${{ matrix.account }})
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ matrix.role }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws-region }}

      - name: Run diff
        id: diff
        env:
          STACKS: ${{ matrix.stacks }}
          ENABLE_DRIFT: ${{ inputs.enable-drift-detection }}
          CDK_DEFAULT_ACCOUNT: ${{ matrix.account }}
          CDK_DEFAULT_REGION: ${{ inputs.aws-region }}
        run: |
          [ -z "$STACKS" ] && echo 'result={"success":true,"stacks":[]}' >> $GITHUB_OUTPUT && exit 0
          
          npx cdk synth --quiet --output cdk.out
          
          mkdir -p /tmp/cdk-runner && cd /tmp/cdk-runner
          echo '{"type":"module","dependencies":{"@aws-cdk/toolkit-lib":"*"}}' > package.json
          npm install --silent
          
          cat > run.js << 'SCRIPT'
          import { Toolkit, StackSelectionStrategy } from '@aws-cdk/toolkit-lib';
          const stacks = (process.env.STACKS || '').split(' ').filter(Boolean);
          const enableDrift = process.env.ENABLE_DRIFT === 'true';
          async function main() {
            const output = { success: false, stacks: [], error: '' };
            try {
              const toolkit = new Toolkit({ ioHost: { notify: async () => {}, requestResponse: async (msg) => msg.defaultResponse } });
              const cx = await toolkit.fromAssemblyDirectory(process.env.CDK_OUT);
              const selector = stacks.length ? { strategy: StackSelectionStrategy.PATTERN_MUST_MATCH, patterns: stacks } : { strategy: StackSelectionStrategy.ALL_STACKS };
              const diffResults = await toolkit.diff(cx, { stacks: selector });
              const fmtVal = (v) => v === undefined || v === null ? null : typeof v === 'object' ? JSON.stringify(v) : String(v);
              for (const [name, diff] of Object.entries(diffResults)) {
                const result = { stackName: name, hasDiff: false, resources: [] };
                for (const [logicalId, resDiff] of Object.entries(diff.resources?.diffs || {})) {
                  const type = resDiff.resourceTypes?.newType || resDiff.resourceTypes?.oldType || 'Unknown';
                  const action = resDiff.isAddition ? 'ADD' : resDiff.isRemoval ? 'REMOVE' : 'UPDATE';
                  const properties = Object.entries(resDiff.propertyDiffs || {}).filter(([_, p]) => p.isDifferent).map(([n, p]) => ({ name: n, impact: p.changeImpact || 'UNKNOWN', oldValue: fmtVal(p.oldValue), newValue: fmtVal(p.newValue) }));
                  result.resources.push({ logicalId, type, action, properties });
                  result.hasDiff = true;
                }
                if (enableDrift) { try { const dr = await toolkit.drift(cx, { stacks: { strategy: StackSelectionStrategy.PATTERN_MUST_MATCH, patterns: [name] } }); result.drift = { status: (dr[name]?.numResourcesWithDrift || 0) > 0 ? 'DRIFTED' : 'IN_SYNC', count: dr[name]?.numResourcesWithDrift || 0 }; } catch {} }
                output.stacks.push(result);
              }
              output.success = true;
            } catch (e) { output.error = e.message || String(e); }
            console.log(JSON.stringify(output));
          }
          main();
          SCRIPT
          
          cd ${{ github.workspace }}/${{ inputs.working-directory }}
          CDK_OUT="$(pwd)/cdk.out" node /tmp/cdk-runner/run.js > /tmp/result.json 2>&1 || true
          RESULT=$(cat /tmp/result.json | tail -1 || echo '{"success":false,"error":"no output","stacks":[]}')
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$RESULT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload result
        uses: actions/upload-artifact@v4
        with:
          name: diff-${{ matrix.account }}
          path: /tmp/result.json
          retention-days: 1

  # ===========================================================================
  # AGGREGATE: Combine multi-account results
  # ===========================================================================
  aggregate:
    name: Aggregate Results
    if: needs.prepare.outputs.is-multi-account == 'true'
    needs: [prepare, diff-multi]
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    outputs:
      combined: ${{ steps.combine.outputs.result }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: /tmp/diffs
          pattern: diff-*

      - name: Combine results
        id: combine
        run: |
          ALL_STACKS='[]'
          for f in /tmp/diffs/*/result.json; do
            if [ -f "$f" ]; then
              STACKS=$(cat "$f" | tail -1 | jq -c '.stacks // []')
              ALL_STACKS=$(echo "$ALL_STACKS" | jq --argjson new "$STACKS" '. + $new')
            fi
          done
          RESULT='{"success":true,"stacks":'$ALL_STACKS'}'
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$RESULT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # ===========================================================================
  # COMMENT: Post PR comment and Slack
  # ===========================================================================
  comment:
    name: Post Comment
    needs: [prepare, diff-single, aggregate]
    if: always() && (needs.diff-single.result == 'success' || needs.aggregate.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Generate comment
        id: comment
        uses: actions/github-script@v7
        env:
          DIFF_SINGLE: ${{ needs.diff-single.outputs.result }}
          DIFF_MULTI: ${{ needs.aggregate.outputs.combined }}
        with:
          script: |
            const raw = process.env.DIFF_SINGLE || process.env.DIFF_MULTI;
            if (!raw) { core.setOutput('comment', '## üîç CDK Diff\n\n‚ö†Ô∏è No diff results'); return; }
            
            let data;
            try { data = JSON.parse(raw); } catch (e) { core.setOutput('comment', `## üîç CDK Diff\n\n‚ùå Parse error`); return; }
            
            const getEnv = (n) => n.toLowerCase().includes('prod') ? 'production' : n.toLowerCase().includes('staging') ? 'staging' : 'dev';
            const cleanId = (id) => id.replace(/[A-F0-9]{8}$/i, '').replace(/([a-z])([A-Z])/g, '$1 $2');
            const shortType = (t) => t.split('::').pop();
            
            let md = '## üîç CDK Diff\n\n';
            if (!data.success) { md += `‚ùå **Error:** ${data.error}\n`; core.setOutput('comment', md); return; }
            
            const changed = data.stacks.filter(s => s.hasDiff);
            const unchanged = data.stacks.filter(s => !s.hasDiff);
            const adds = data.stacks.reduce((n, s) => n + s.resources.filter(r => r.action === 'ADD').length, 0);
            const updates = data.stacks.reduce((n, s) => n + s.resources.filter(r => r.action === 'UPDATE').length, 0);
            const removes = data.stacks.reduce((n, s) => n + s.resources.filter(r => r.action === 'REMOVE').length, 0);
            
            if (changed.length === 0) { md += '‚úÖ **No changes**\n'; }
            else {
              const parts = [];
              if (adds) parts.push(`üü¢ ${adds} to add`);
              if (updates) parts.push(`üü° ${updates} to update`);
              if (removes) parts.push(`üî¥ ${removes} to destroy`);
              md += `**${parts.join(' ¬∑ ')}**\n\n`;
              
              for (const stack of changed) {
                md += `### ${stack.stackName}\n> _${getEnv(stack.stackName)}_`;
                if (stack.drift) md += stack.drift.status === 'DRIFTED' ? ` ¬∑ ‚ö†Ô∏è drift (${stack.drift.count})` : ' ¬∑ ‚úì no drift';
                md += '\n\n';
                
                const byAction = { ADD: [], UPDATE: [], REMOVE: [] };
                for (const res of stack.resources) byAction[res.action].push(res);
                
                if (byAction.ADD.length) {
                  md += '**‚ûï Create**\n';
                  for (const r of byAction.ADD) {
                    md += `- \`${shortType(r.type)}\` **${cleanId(r.logicalId)}**\n`;
                    for (const p of r.properties) if (p.newValue) md += `  - \`${p.name}\`: ${p.newValue}\n`;
                  }
                  md += '\n';
                }
                if (byAction.UPDATE.length) {
                  md += '**‚úèÔ∏è Update**\n';
                  for (const r of byAction.UPDATE) {
                    md += `- \`${shortType(r.type)}\` **${cleanId(r.logicalId)}**${r.properties.some(p => p.impact === 'WILL_REPLACE') ? ' ‚ö†Ô∏è' : ''}\n`;
                    for (const p of r.properties) {
                      md += `  - \`${p.name}\`${p.impact === 'WILL_REPLACE' ? ' ‚ö†Ô∏èreplace' : ''}\n`;
                      md += `    **OLD:** ${p.oldValue || '_(none)_'}\n    **NEW:** ${p.newValue || '_(removed)_'}\n`;
                    }
                  }
                  md += '\n';
                }
                if (byAction.REMOVE.length) {
                  md += '**üóëÔ∏è Destroy**\n';
                  for (const r of byAction.REMOVE) md += `- \`${shortType(r.type)}\` **${cleanId(r.logicalId)}**\n`;
                  md += '\n';
                }
              }
            }
            if (unchanged.length) md += `<details><summary>‚úÖ ${unchanged.length} unchanged</summary>\n\n${unchanged.map(s => `- ${s.stackName}`).join('\n')}\n</details>\n`;
            
            core.setOutput('comment', md);
            
            // Slack
            const prUrl = '${{ github.event.pull_request.html_url || format('https://github.com/{0}/pull/{1}', github.repository, inputs.pr-number) }}';
            const prNum = '${{ inputs.pr-number || github.event.pull_request.number }}';
            const repo = '${{ github.repository }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';
            
            const blocks = [
              { type: 'header', text: { type: 'plain_text', text: 'üîç CDK Diff', emoji: true } },
              { type: 'context', elements: [{ type: 'mrkdwn', text: `<${prUrl}|PR #${prNum}> in \`${repo}\`` }] },
              { type: 'section', fields: [
                { type: 'mrkdwn', text: `üü¢ *Add*\n${adds}` }, { type: 'mrkdwn', text: `üü° *Update*\n${updates}` },
                { type: 'mrkdwn', text: `üî¥ *Remove*\n${removes}` }, { type: 'mrkdwn', text: `üì¶ *Stacks*\n${changed.length}` }
              ]},
              { type: 'actions', elements: [
                { type: 'button', text: { type: 'plain_text', text: 'View PR' }, url: prUrl },
                { type: 'button', text: { type: 'plain_text', text: 'Workflow' }, url: runUrl }
              ]}
            ];
            
            for (const stack of changed.slice(0, 5)) {
              blocks.push({ type: 'divider' });
              let txt = `üì¶ *${stack.stackName}* _(${getEnv(stack.stackName)})_`;
              const byAction = { ADD: [], UPDATE: [], REMOVE: [] };
              for (const res of stack.resources) byAction[res.action].push(res);
              if (byAction.ADD.length) { txt += '\nüü¢ '; for (const r of byAction.ADD) txt += `\`${shortType(r.type)}\` `; }
              if (byAction.UPDATE.length) { txt += '\nüü° '; for (const r of byAction.UPDATE) txt += `\`${shortType(r.type)}\` `; }
              if (byAction.REMOVE.length) { txt += '\nüî¥ '; for (const r of byAction.REMOVE) txt += `\`${shortType(r.type)}\` `; }
              blocks.push({ type: 'section', text: { type: 'mrkdwn', text: txt } });
            }
            if (changed.length > 5) blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: `_+${changed.length - 5} more stacks..._` }] });
            
            core.setOutput('slack_blocks', JSON.stringify(blocks));

      - name: Post PR comment
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: cdk-diff
          number: ${{ inputs.pr-number || github.event.pull_request.number }}
          message: ${{ steps.comment.outputs.comment }}

      - name: Check Slack label
        id: check-label
        env:
          SLACK_WEBHOOK: ${{ secrets.slack-webhook-url }}
        uses: actions/github-script@v7
        with:
          script: |
            if (!process.env.SLACK_WEBHOOK) { core.setOutput('notify', 'false'); return; }
            const prNum = ${{ inputs.pr-number || github.event.pull_request.number || 0 }};
            if (!prNum) { core.setOutput('notify', 'false'); return; }
            const { data: pr } = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNum });
            core.setOutput('notify', pr.labels.some(l => l.name === '${{ inputs.slack-notify-label }}') ? 'true' : 'false');

      - name: Send Slack
        if: steps.check-label.outputs.notify == 'true'
        uses: slackapi/slack-github-action@v1.25.0
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.slack-webhook-url }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        with:
          payload: '{"blocks": ${{ steps.comment.outputs.slack_blocks }} }'
