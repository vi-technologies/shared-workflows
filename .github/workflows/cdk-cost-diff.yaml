# =============================================================================
# CDK COST DIFF WORKFLOW
# =============================================================================
# Estimates the monthly cost impact of CDK infrastructure changes in PRs.
# Consumes the structured diff JSON from cdk-diff.yaml and queries the
# AWS Pricing API (GetProducts) to calculate per-resource cost deltas.
#
# FEATURES:
#   - Prices changed resources using the native AWS Pricing API (free, no extra keys)
#   - Uses @aws-sdk/client-pricing (official SDK) — no CLI shell-outs
#   - Extensible resource-map.json for adding new resource type pricing
#   - Posts a sticky PR comment with a cost summary table
#   - Handles ADD, UPDATE, REMOVE actions with before/after cost comparison
#   - Resources without pricing data are listed as "no cost data"
#   - In-memory pricing cache to avoid redundant API calls
#
# USAGE:
#   jobs:
#     diff:
#       uses: vi-technologies/shared-workflows/.github/workflows/cdk-diff.yaml@main
#       with:
#         aws-role-arn: 'arn:aws:iam::123456789012:role/GithubActionsRole'
#         stacks: 'Stack1 Stack2'
#     cost:
#       needs: diff
#       uses: vi-technologies/shared-workflows/.github/workflows/cdk-cost-diff.yaml@main
#       with:
#         diff-json: ${{ needs.diff.outputs.result }}
#         aws-role-arn: 'arn:aws:iam::123456789012:role/GithubActionsRole'
# =============================================================================

name: CDK Cost Diff

on:
  workflow_call:
    inputs:
      diff-json:
        description: 'Structured diff JSON string (output from cdk-diff.yaml)'
        required: true
        type: string

      aws-account-id:
        description: 'AWS account ID. If provided, role ARN is built as arn:aws:iam::<id>:role/<role-name>. If omitted, aws-role-name must be a full ARN.'
        required: false
        type: string
        default: ''

      aws-role-name:
        description: 'AWS IAM role name or full ARN'
        required: true
        type: string

      aws-region:
        description: 'AWS region where the resources are deployed (used for pricing lookup)'
        required: false
        type: string
        default: 'us-east-1'

jobs:
  cost:
    name: Cost Estimate
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      pull-requests: write

    steps:
      # =======================================================================
      # SETUP
      # =======================================================================
      - name: Checkout (for resource-map.json)
        uses: actions/checkout@v4
        with:
          repository: vi-technologies/shared-workflows
          ref: ${{ github.job_workflow_sha }}
          sparse-checkout: .github/pricing
          path: _shared

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws-account-id != '' && format('arn:aws:iam::{0}:role/{1}', inputs.aws-account-id, inputs.aws-role-name) || inputs.aws-role-name }}
          role-duration-seconds: 3600
          aws-region: us-east-1

      - name: Install AWS SDK Pricing client
        run: npm install @aws-sdk/client-pricing

      # =======================================================================
      # COST CALCULATION (via actions/github-script + @aws-sdk/client-pricing)
      # =======================================================================
      - name: Calculate cost diff
        id: cost
        uses: actions/github-script@v7
        env:
          DIFF_JSON: ${{ inputs.diff-json }}
          PRICING_REGION: ${{ inputs.aws-region }}
        with:
          result-encoding: string
          script: |
            const fs = require('fs');
            const path = require('path');
            const { PricingClient, GetProductsCommand } = require('@aws-sdk/client-pricing');

            // =================================================================
            // Region code → AWS Pricing API "location" name
            // The Pricing API works more reliably with human-readable names.
            // =================================================================
            const REGION_NAMES = {
              'us-east-1':      'US East (N. Virginia)',
              'us-east-2':      'US East (Ohio)',
              'us-west-1':      'US West (N. California)',
              'us-west-2':      'US West (Oregon)',
              'af-south-1':     'Africa (Cape Town)',
              'ap-east-1':      'Asia Pacific (Hong Kong)',
              'ap-south-1':     'Asia Pacific (Mumbai)',
              'ap-south-2':     'Asia Pacific (Hyderabad)',
              'ap-southeast-1': 'Asia Pacific (Singapore)',
              'ap-southeast-2': 'Asia Pacific (Sydney)',
              'ap-southeast-3': 'Asia Pacific (Jakarta)',
              'ap-northeast-1': 'Asia Pacific (Tokyo)',
              'ap-northeast-2': 'Asia Pacific (Seoul)',
              'ap-northeast-3': 'Asia Pacific (Osaka)',
              'ca-central-1':   'Canada (Central)',
              'eu-central-1':   'EU (Frankfurt)',
              'eu-central-2':   'EU (Zurich)',
              'eu-west-1':      'EU (Ireland)',
              'eu-west-2':      'EU (London)',
              'eu-west-3':      'EU (Paris)',
              'eu-south-1':     'EU (Milan)',
              'eu-south-2':     'EU (Spain)',
              'eu-north-1':     'EU (Stockholm)',
              'il-central-1':   'Israel (Tel Aviv)',
              'me-south-1':     'Middle East (Bahrain)',
              'me-central-1':   'Middle East (UAE)',
              'sa-east-1':      'South America (Sao Paulo)',
            };

            // =================================================================
            // Load inputs
            // =================================================================
            const resourceMap = JSON.parse(
              fs.readFileSync(path.join(process.env.GITHUB_WORKSPACE, '_shared/.github/pricing/resource-map.json'), 'utf8')
            );

            let diffData;
            try { diffData = JSON.parse(process.env.DIFF_JSON); }
            catch (e) { core.setFailed('Failed to parse diff JSON: ' + e.message); return ''; }

            const region = process.env.PRICING_REGION || 'us-east-1';
            const locationName = REGION_NAMES[region] || REGION_NAMES['us-east-1'];

            // Pricing API is only available in us-east-1 and ap-south-1
            const pricing = new PricingClient({ region: 'us-east-1' });

            // =================================================================
            // Pricing cache
            // =================================================================
            const priceCache = new Map();

            function cacheKey(serviceCode, filters) {
              return JSON.stringify({ serviceCode, filters: [...filters].sort((a, b) => a.Field.localeCompare(b.Field)) });
            }

            // =================================================================
            // Query AWS Pricing API via SDK
            // =================================================================
            async function queryPrice(serviceCode, filters) {
              const key = cacheKey(serviceCode, filters);
              if (priceCache.has(key)) return priceCache.get(key);

              const allFilters = [
                ...filters.map(f => ({ Type: 'TERM_MATCH', Field: f.Field, Value: f.Value })),
                { Type: 'TERM_MATCH', Field: 'location', Value: locationName }
              ];

              try {
                const resp = await pricing.send(new GetProductsCommand({
                  ServiceCode: serviceCode,
                  Filters: allFilters,
                  MaxResults: 1
                }));

                if (!resp.PriceList?.length) { priceCache.set(key, null); return null; }

                const product = JSON.parse(resp.PriceList[0]);
                const onDemand = product.terms?.OnDemand;
                if (!onDemand) { priceCache.set(key, null); return null; }

                for (const offerKey of Object.keys(onDemand)) {
                  const priceDims = onDemand[offerKey]?.priceDimensions;
                  if (!priceDims) continue;
                  for (const dimKey of Object.keys(priceDims)) {
                    const usd = parseFloat(priceDims[dimKey]?.pricePerUnit?.USD || '0');
                    if (usd > 0) {
                      const entry = { usd, unit: priceDims[dimKey]?.unit || '', description: priceDims[dimKey]?.description || '' };
                      priceCache.set(key, entry);
                      return entry;
                    }
                  }
                }
                priceCache.set(key, null);
                return null;
              } catch (e) {
                core.warning(`Pricing API error for ${serviceCode}: ${e.message}`);
                priceCache.set(key, null);
                return null;
              }
            }

            // =================================================================
            // Helpers
            // =================================================================
            function resolveFilterValue(valueDef, properties, useNew) {
              if (valueDef.default && !valueDef.cfProperty) return valueDef.default;
              if (valueDef.cfProperty) {
                const prop = (properties || []).find(p => p.name === valueDef.cfProperty);
                if (prop) {
                  const val = useNew ? prop.newValue : prop.oldValue;
                  if (val && val !== 'null' && val !== 'undefined') return val;
                }
                return valueDef.default || null;
              }
              return null;
            }

            function buildFilters(mapping, properties, useNew) {
              const resolved = [];
              for (const filter of mapping.filters) {
                const value = resolveFilterValue(filter.Value, properties, useNew);
                if (value) resolved.push({ Field: filter.Field, Value: value });
              }
              return resolved;
            }

            function monthlyCost(unitPrice, mapping) {
              if (mapping.monthlyHours) return unitPrice * mapping.monthlyHours;
              if (mapping.monthlyQuantity) return unitPrice * mapping.monthlyQuantity;
              return unitPrice;
            }

            function fmt(n) {
              if (n === null || n === undefined) return '-';
              return '$' + n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }

            function fmtDelta(n) {
              if (n === null || n === undefined) return 'no cost data';
              if (Math.abs(n) < 0.005) return '~$0.00';
              return (n > 0 ? '+' : '') + '$' + n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }

            function shortType(t) { return t.split('::').pop(); }
            function cleanId(id) { return id.replace(/[A-F0-9]{8}$/i, '').replace(/([a-z])([A-Z])/g, '$1 $2'); }

            // =================================================================
            // Main
            // =================================================================
            const rows = [];
            let totalDelta = 0;
            let pricedCount = 0;

            core.info(`Pricing region: ${region} (${locationName})`);
            core.info(`Resource types in map: ${Object.keys(resourceMap).filter(k => !k.startsWith('_')).length}`);

            for (const stack of (diffData.stacks || [])) {
              if (!stack.hasDiff) continue;

              for (const res of (stack.resources || [])) {
                if (res.type.startsWith('_') || res.type === 'Unknown') continue;

                const mapping = resourceMap[res.type];
                if (!mapping) {
                  rows.push({ stack: stack.stackName, logicalId: cleanId(res.logicalId), type: shortType(res.type), detail: '', action: res.action, before: null, after: null, delta: null });
                  continue;
                }

                core.info(`  Pricing ${res.action} ${res.type} (${res.logicalId})...`);
                let beforeCost = null, afterCost = null;

                if (res.action === 'ADD') {
                  const price = await queryPrice(mapping.serviceCode, buildFilters(mapping, res.properties, true));
                  if (price) { afterCost = monthlyCost(price.usd, mapping); pricedCount++; }
                } else if (res.action === 'REMOVE') {
                  const price = await queryPrice(mapping.serviceCode, buildFilters(mapping, res.properties, false));
                  if (price) { beforeCost = monthlyCost(price.usd, mapping); pricedCount++; }
                } else if (res.action === 'UPDATE') {
                  const oldPrice = await queryPrice(mapping.serviceCode, buildFilters(mapping, res.properties, false));
                  const newPrice = await queryPrice(mapping.serviceCode, buildFilters(mapping, res.properties, true));
                  if (oldPrice) beforeCost = monthlyCost(oldPrice.usd, mapping);
                  if (newPrice) afterCost = monthlyCost(newPrice.usd, mapping);
                  if (oldPrice || newPrice) pricedCount++;
                }

                const delta = (beforeCost !== null || afterCost !== null) ? (afterCost || 0) - (beforeCost || 0) : null;
                if (delta !== null) totalDelta += delta;

                let detail = '';
                if (res.action === 'UPDATE') {
                  for (const f of mapping.filters) {
                    if (f.Value.cfProperty) {
                      const prop = (res.properties || []).find(p => p.name === f.Value.cfProperty);
                      if (prop && prop.oldValue && prop.newValue && prop.oldValue !== prop.newValue) {
                        detail = `${prop.oldValue} \u2192 ${prop.newValue}`;
                        break;
                      }
                    }
                  }
                }

                rows.push({ stack: stack.stackName, logicalId: cleanId(res.logicalId), type: shortType(res.type), detail, action: res.action, before: beforeCost, after: afterCost, delta });
              }
            }

            // =================================================================
            // Build markdown
            // =================================================================
            let md = '## \uD83D\uDCB0 CDK Cost Estimate\n\n';

            if (rows.length === 0) {
              md += 'No infrastructure changes with cost impact detected.\n';
            } else {
              const adds = rows.filter(r => r.action === 'ADD').length;
              const updates = rows.filter(r => r.action === 'UPDATE').length;
              const removes = rows.filter(r => r.action === 'REMOVE').length;
              const unmapped = rows.filter(r => r.delta === null).length;

              md += `**Estimated monthly impact: ${fmtDelta(totalDelta)}/mo**\n\n`;
              md += `> ${adds} added \u00B7 ${updates} updated \u00B7 ${removes} removed \u00B7 ${pricedCount} priced \u00B7 ${unmapped} without pricing data\n\n`;
              md += '| Stack | Resource | Type | Change | Before | After | Delta |\n';
              md += '|-------|----------|------|--------|-------:|------:|------:|\n';

              for (const r of rows) {
                const typeStr = r.detail ? `${r.type} (${r.detail})` : r.type;
                const icon = r.action === 'ADD' ? '\uD83D\uDFE2' : r.action === 'REMOVE' ? '\uD83D\uDD34' : '\uD83D\uDFE1';
                md += `| ${r.stack} | ${r.logicalId} | ${typeStr} | ${icon} ${r.action} | ${fmt(r.before)} | ${fmt(r.after)} | ${fmtDelta(r.delta)} |\n`;
              }

              if (unmapped > 0) {
                md += `\n> \u2139\uFE0F **${unmapped}** resource(s) have no pricing data. Add entries to \`.github/pricing/resource-map.json\` to extend coverage.\n`;
              }

              const usedNotes = new Set();
              for (const r of rows) {
                if (r.delta === null) continue;
                const fullType = Object.keys(resourceMap).find(k => shortType(k) === r.type);
                if (fullType && resourceMap[fullType].note) usedNotes.add(resourceMap[fullType].note);
              }
              if (usedNotes.size > 0) {
                md += '\n<details><summary>\uD83D\uDCDD Estimation notes</summary>\n\n';
                for (const note of usedNotes) md += `- ${note}\n`;
                md += '\n</details>\n';
              }
            }

            md += '\n---\n';
            md += `<sub>Prices: AWS Pricing API (on-demand, ${locationName}). Estimates are approximate and reflect unit costs only.</sub>\n`;

            core.setOutput('comment', md);
            return md;

      # =======================================================================
      # POST PR COMMENT
      # =======================================================================
      - name: Post cost estimate comment
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: cdk-cost-estimate
          message: ${{ steps.cost.outputs.comment }}
