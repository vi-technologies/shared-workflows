# =============================================================================
# CDK DEPLOY WORKFLOW
# =============================================================================
# This reusable workflow performs CDK deploy operations and sends nicely
# formatted Slack notifications with change summaries.
#
# FEATURES:
#   - Runs `cdk deploy` on specified stacks
#   - Parses diff output to show clean change summaries
#   - Sends formatted Slack notifications (success/failure)
#   - Supports dry-run mode for testing
# =============================================================================

name: CDK Deploy

on:
  workflow_call:
    inputs:
      # -----------------------------------------------------------------------
      # Build Environment Configuration
      # -----------------------------------------------------------------------
      working-directory:
        description: 'Working directory for CDK commands'
        required: false
        type: string
        default: '.'

      python-version:
        description: 'Python version (for Python CDK apps)'
        required: false
        type: string
        default: ''

      node-version:
        description: 'Node.js version'
        required: false
        type: string
        default: '20'

      install-command:
        description: 'Command to install dependencies'
        required: false
        type: string
        default: 'npm ci'

      # -----------------------------------------------------------------------
      # AWS Configuration
      # -----------------------------------------------------------------------
      aws-region:
        description: 'AWS region'
        required: false
        type: string
        default: 'us-east-1'

      aws-role-arn:
        description: 'AWS IAM role ARN to assume'
        required: true
        type: string

      # -----------------------------------------------------------------------
      # CDK Deploy Configuration
      # -----------------------------------------------------------------------
      stacks:
        description: 'Space-separated list of stack names to deploy'
        required: true
        type: string

      require-approval:
        description: 'CDK approval level (never, any-change, broadening)'
        required: false
        type: string
        default: 'never'

      dry-run:
        description: 'If true, only run diff without deploying'
        required: false
        type: boolean
        default: false

      # -----------------------------------------------------------------------
      # Slack Configuration
      # -----------------------------------------------------------------------
      slack-channel-name:
        description: 'Slack channel name (for display purposes)'
        required: false
        type: string
        default: 'devops'

    secrets:
      slack-webhook-url:
        description: 'Slack webhook URL for notifications'
        required: false

jobs:
  deploy:
    name: CDK Deploy
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
      # =======================================================================
      # SETUP
      # =======================================================================
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        if: inputs.python-version != ''
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}

      - name: Install dependencies
        run: ${{ inputs.install-command }}

      - name: Install AWS CDK CLI
        run: npm install -g aws-cdk

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws-role-arn }}
          role-duration-seconds: 3600
          aws-region: ${{ inputs.aws-region }}

      # =======================================================================
      # CDK SYNTH & DIFF (using toolkit-lib for structured output)
      # =======================================================================
      - name: CDK Synth
        run: npx cdk synth --quiet --output cdk.out

      - name: Run CDK diff
        id: diff
        env:
          STACKS: ${{ inputs.stacks }}
        run: |
          echo "Running CDK diff for: $STACKS"
          
          mkdir -p /tmp/cdk-runner && cd /tmp/cdk-runner
          echo '{"type":"module","dependencies":{"@aws-cdk/toolkit-lib":"*"}}' > package.json
          npm install --silent
          
          cat > run.js << 'SCRIPT'
          import { Toolkit, StackSelectionStrategy } from '@aws-cdk/toolkit-lib';
          const stacks = (process.env.STACKS || '').split(' ').filter(Boolean);
          async function main() {
            const output = { success: false, stacks: [], error: '' };
            try {
              const toolkit = new Toolkit({ ioHost: { notify: async () => {}, requestResponse: async (msg) => msg.defaultResponse } });
              const cx = await toolkit.fromAssemblyDirectory(process.env.CDK_OUT);
              const selector = stacks.length ? { strategy: StackSelectionStrategy.PATTERN_MUST_MATCH, patterns: stacks } : { strategy: StackSelectionStrategy.ALL_STACKS };
              const diffResults = await toolkit.diff(cx, { stacks: selector });
              const fmtVal = (v) => v === undefined || v === null ? null : typeof v === 'object' ? JSON.stringify(v) : String(v);
              for (const [name, diff] of Object.entries(diffResults)) {
                const result = { stackName: name, hasDiff: false, resources: [] };
                for (const [logicalId, resDiff] of Object.entries(diff.resources?.diffs || {})) {
                  const type = resDiff.resourceTypes?.newType || resDiff.resourceTypes?.oldType || 'Unknown';
                  const action = resDiff.isAddition ? 'ADD' : resDiff.isRemoval ? 'REMOVE' : 'UPDATE';
                  const properties = Object.entries(resDiff.propertyDiffs || {}).filter(([_, p]) => p.isDifferent).map(([n, p]) => ({ name: n, impact: p.changeImpact || 'UNKNOWN', oldValue: fmtVal(p.oldValue), newValue: fmtVal(p.newValue) }));
                  result.resources.push({ logicalId, type, action, properties });
                  result.hasDiff = true;
                }
                output.stacks.push(result);
              }
              output.success = true;
            } catch (e) { output.error = e.message || String(e); }
            console.log(JSON.stringify(output));
          }
          main();
          SCRIPT
          
          cd ${{ github.workspace }}/${{ inputs.working-directory }}
          CDK_OUT="$(pwd)/cdk.out" node /tmp/cdk-runner/run.js > /tmp/diff_result.json 2>&1 || true
          RESULT=$(cat /tmp/diff_result.json | tail -1 || echo '{"success":false,"error":"no output","stacks":[]}')
          
          # Save for later steps
          echo "$RESULT" > diff_result.json
          
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$RESULT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # =======================================================================
      # CDK DEPLOY
      # =======================================================================
      - name: Deploy stacks
        id: deploy
        if: inputs.dry-run != true
        env:
          STACKS: ${{ inputs.stacks }}
        run: |
          echo "=== Deploying stacks ==="
          echo "$STACKS"
          echo ""
          npx cdk deploy $STACKS --require-approval ${{ inputs.require-approval }}

      - name: Skip deploy (dry run)
        if: inputs.dry-run == true
        run: |
          echo "üîç DRY RUN MODE - Skipping actual deployment"
          echo "Would have deployed: ${{ inputs.stacks }}"

      # =======================================================================
      # SLACK NOTIFICATION (inline formatter)
      # =======================================================================
      - name: Format and send Slack notification
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.slack-webhook-url }}
          JOB_STATUS: ${{ job.status }}
          DRY_RUN: ${{ inputs.dry-run }}
          REPO: ${{ github.repository }}
          ACTOR: ${{ github.actor }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          # Skip if no webhook URL provided
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "No Slack webhook URL provided, skipping notification"
            exit 0
          fi
          
          # Read diff result
          if [ -f diff_result.json ]; then
            DIFF_JSON=$(cat diff_result.json)
          else
            DIFF_JSON='{"success":true,"stacks":[]}'
          fi
          
          # Create inline formatter script
          cat > /tmp/format-slack.js << 'FORMATTER_SCRIPT'
          const getEnv = (n) => n.toLowerCase().includes('prod') ? 'production' : n.toLowerCase().includes('staging') ? 'staging' : 'dev';
          const cleanId = (id) => id.replace(/[A-F0-9]{8}$/i, '').replace(/([a-z])([A-Z])/g, '$1 $2');
          const shortType = (t) => t.split('::').pop();
          
          function formatSlackBlocks(data, context) {
            const { repo, runUrl, actor, jobStatus } = context;
            const changed = data.stacks?.filter(s => s.hasDiff) || [];
            const adds = data.stacks?.reduce((n, s) => n + s.resources.filter(r => r.action === 'ADD').length, 0) || 0;
            const updates = data.stacks?.reduce((n, s) => n + s.resources.filter(r => r.action === 'UPDATE').length, 0) || 0;
            const removes = data.stacks?.reduce((n, s) => n + s.resources.filter(r => r.action === 'REMOVE').length, 0) || 0;
            
            const headerText = jobStatus === 'success' ? '‚úÖ CDK Deploy Succeeded' : '‚ùå CDK Deploy Failed';
            const blocks = [
              { type: 'header', text: { type: 'plain_text', text: headerText, emoji: true } },
              { type: 'context', elements: [{ type: 'mrkdwn', text: `\`${repo}\`${actor ? ` by ${actor}` : ''}` }] },
              { type: 'section', fields: [
                { type: 'mrkdwn', text: `üü¢ *Add*\n${adds}` },
                { type: 'mrkdwn', text: `üü° *Update*\n${updates}` },
                { type: 'mrkdwn', text: `üî¥ *Remove*\n${removes}` },
                { type: 'mrkdwn', text: `üì¶ *Stacks*\n${changed.length}` }
              ]},
              { type: 'actions', elements: [{ type: 'button', text: { type: 'plain_text', text: 'Workflow' }, url: runUrl }] }
            ];
            
            for (const stack of changed.slice(0, 5)) {
              blocks.push({ type: 'divider' });
              let txt = `üì¶ *${stack.stackName}* _(${getEnv(stack.stackName)})_`;
              const byAction = { ADD: [], UPDATE: [], REMOVE: [] };
              for (const res of stack.resources) byAction[res.action].push(res);
              
              if (byAction.ADD.length) {
                txt += '\nüü¢ *Create*';
                for (const r of byAction.ADD) txt += `\n‚Ä¢ \`${shortType(r.type)}\` *${cleanId(r.logicalId)}*`;
              }
              if (byAction.UPDATE.length) {
                txt += '\nüü° *Update*';
                for (const r of byAction.UPDATE) {
                  txt += `\n‚Ä¢ \`${shortType(r.type)}\` *${cleanId(r.logicalId)}*`;
                  for (const p of r.properties.slice(0, 2)) {
                    txt += `\n   \`${p.name}\`${p.impact === 'WILL_REPLACE' ? ' ‚ö†Ô∏è' : ''}`;
                  }
                }
              }
              if (byAction.REMOVE.length) {
                txt += '\nüî¥ *Destroy*';
                for (const r of byAction.REMOVE) txt += `\n‚Ä¢ \`${shortType(r.type)}\` *${cleanId(r.logicalId)}*`;
              }
              blocks.push({ type: 'section', text: { type: 'mrkdwn', text: txt } });
            }
            return blocks;
          }
          
          try {
            const data = JSON.parse(process.argv[2]);
            const context = JSON.parse(process.argv[3]);
            console.log(JSON.stringify(formatSlackBlocks(data, context)));
          } catch (e) {
            console.log(JSON.stringify([{ type: 'section', text: { type: 'mrkdwn', text: `‚ùå Format error: ${e.message}` }}]));
          }
          FORMATTER_SCRIPT
          
          # Build context
          CONTEXT_JSON=$(jq -nc \
            --arg repo "$REPO" \
            --arg runUrl "$RUN_URL" \
            --arg actor "$ACTOR" \
            --arg jobStatus "$JOB_STATUS" \
            '{repo: $repo, runUrl: $runUrl, actor: $actor, jobStatus: $jobStatus}')
          
          # Format and send
          SLACK_BLOCKS=$(node /tmp/format-slack.js "$DIFF_JSON" "$CONTEXT_JSON")
          PAYLOAD=$(jq -nc --argjson blocks "$SLACK_BLOCKS" '{blocks: $blocks}')
          curl -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK_URL"
